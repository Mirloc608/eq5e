const MODULE_ID = "eq5e-pet-beastlord-warder";

const BASE = "systems/eq5e/bundles/eq5e-pet-beastlord-warder";
const MOD = "eq5e-pet-beastlord-warder";

async function _fetchJSON(path) {
  const res = await fetch(path);
  if (!res.ok) throw new Error(`Fetch failed ${res.status} for ${path}`);
  return res.json();
}


function _modulePath(moduleId, rel) {
  // If running as a separate module, use its path.
  try {
    const mod = game.modules?.get(moduleId);
    if (mod?.active && mod?.path) return `${mod.path}/${rel}`;
  } catch (e) {}
  // Bundled into the system: fall back to system bundle folder.
  return `systems/eq5e/bundles/${moduleId}/${rel}`;
}

function _stableHash(obj) {
  const s = JSON.stringify(obj);
  let h = 2166136261;
  for (let i = 0; i < s.length; i++) { h ^= s.charCodeAt(i); h = Math.imul(h, 16777619); }
  return (h >>> 0).toString(16);
}

async function ensureWorldActorPack({ key, label }) {
  const existing = game.packs?.get(key);
  if (existing) return existing;
  if (!game.user.isGM) throw new Error("Only GM can create world compendiums.");
  return CompendiumCollection.createCompendium({
    label,
    name: key.split(".")[1],
    type: "Actor",
    package: "world"
  });
}

async function upsertActorsByName(pack, actors) {
  const existing = await pack.getDocuments();
  const byName = new Map(existing.map(a => [a.name, a]));
  const toCreate = [];
  const toUpdate = [];
  for (const a of (actors ?? [])) {
    const name = a?.name;
    if (!name) continue;
    const doc = byName.get(name);
    const h = _stableHash(a);
    if (!doc) {
      a.flags = a.flags ?? {}; a.flags.eq5e = a.flags.eq5e ?? {};
      a.flags.eq5e.derivedHash = h;
      toCreate.push(a);
    } else {
      const old = doc?.flags?.eq5e?.derivedHash;
      if (old !== h) {
        const upd = foundry.utils.duplicate(a);
        upd._id = doc.id;
        upd.flags = upd.flags ?? {}; upd.flags.eq5e = upd.flags.eq5e ?? {};
        upd.flags.eq5e.derivedHash = h;
        toUpdate.push(upd);
      }
    }
  }
  if (toCreate.length) await pack.documentClass.createDocuments(toCreate, { pack: pack.collection });
  if (toUpdate.length) await pack.documentClass.updateDocuments(toUpdate, { pack: pack.collection });
  return { created: toCreate.length, updated: toUpdate.length };
}

export async function generateWarderPack() {
  const warders = await _fetchJSON(_modulePath(MOD, "data/warders.json"));
  const pack = await ensureWorldActorPack({ key: "world.eq5e-beastlord-warders", label: "EQ5e Beastlord Warders" });
  const res = await upsertActorsByName(pack, warders);
  ui.notifications?.info(`EQ5E: Warder pack upserted: created ${res.created}, updated ${res.updated}.`);
  return { ok: true, ...res };
}

Hooks.once("init", () => {
  game.settings.register("eq5e", "beastlordWardersOnStartup", {
    name: "Generate Beastlord warder actor pack on startup",
    hint: "Creates/updates world.eq5e-beastlord-warders with Wolf/Bear/Tiger warders.",
    scope: "world",
    config: true,
    type: Boolean,
    default: true
  });
});

Hooks.once("ready", async () => {
  if (!game.user.isGM) return;
  try {
    if (game.settings.get("eq5e", "beastlordWardersOnStartup")) await generateWarderPack();
  } catch (e) {
    console.error("[EQ5E] Beastlord warder startup failed", e);
  }
});
